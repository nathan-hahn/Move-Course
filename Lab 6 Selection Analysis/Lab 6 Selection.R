##### Lab 6: Selection Models for Animal Movement Data #####
## ECOL592
## 2021-11-15

#' This lab is a guide to fitting selection models for animal movement data. The code will guide you through models
#' for Resource Selection Functions (RSFs) using third order selection, Step Selection Functions (SSFs) using fourth
#' order selection, and integrated Step Selection Functions (iSSFs) which build on SSFs to incorporate movement
#' properties into the models and account for correlations between environmental variables and movement behaviors. 
#' The code uses data from a single deer in the Piceance Basin of Colorado, and uses a spatial data set of natural, 
#' topographic, and human footprint variables. All models use the same data and model statements, so as you run 
#' through each model, pay close attention to how results change and think about how this impacts model choice.
#' 
#' This code relies heavily on the `amt` movement R package to fit and visualize models. As you work through the code 
#' and questions, we suggest you reference their documentation for further examples and explanations:  
#' 
#' Fieberg et al. 2020: https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2656.13441


install.packages('amt') 
install.packages('tidyverse') # should already be installed from previous labs
install.packages('sjPlot') # should already be installed from previous labs
install.packages('raster') # should already be installed from previous labs

library(amt)
library(tidyverse)
library(sjPlot)
library(raster)


##### 1a. Prepare Data #####

# read data
movdata <- read.csv('deer_dates.csv')
movdata$id <- 'deer.1'

# create date object
movdata$date <- as.POSIXct(movdata$date)

# make a move object for the amt package - we will use the id, which is a
#         combination of the animal's name and collar number
track <- make_track(movdata, .x = X, .y = Y, .t = date, id = id)

# create a nested dataframe - needed for multiple ids
t1 <- track %>% nest(data = -"id")

# create bursts and traj - map the two functions to a nested dataset t1
t2 <- t1 %>% 
  mutate(steps = map(data, function(x) 
    x %>% track_resample(rate = minutes(60), tolerance = minutes(30)) %>% steps_by_burst() ))

#' QUESTION: What did these steps just do? What are the new variables that we have in the data set now? 
#' What is the difference between the column `x1_` and `x2_`?

head(t2) # nested object
head(t2$steps)# check out the trajectory information - what is x1_ vs x2_?

#' Lets plot the step length and turning angle distributions

# Plot at step length distribution
t2 %>% dplyr::select(id, steps) %>% unnest(cols = steps) %>% 
  ggplot(aes(sl_, fill = factor(id))) + geom_density(alpha = 0.4)

# Plot at turning angle distribution
t2 %>% dplyr::select(id, steps) %>% unnest(cols = steps) %>% 
  ggplot(aes(ta_, fill = factor(id))) + geom_density(alpha = 0.4)

#' QUESTION: What do these graphs suggest about the step length and turning angle distributions in the data?
#' How should we model them?


##### 1b. Generate random samples #####
#' We will use amt functions to make random samples for our models. First, we will generate random points for the rsf
#' model using the `random_points` function. We will use an mcp home range estimator to generate the random points.
#' We are only using one individual, but the code is set up to scale with multiple individuals using the nest and unest
#' functions, as long as you identify the individuals using a column called `id`.

## make random points for RSF
rsf.randpoints <- t2 %>%
  mutate(rp = map(data, ~ .x %>% random_points(n = 6000, hr = 'mcp'))) %>% 
  dplyr::select(id, rp) %>%  unnest(cols = rp)

rsf.usedpoints <- t2 %>%
  dplyr::select(id, data) %>% unnest(cols = data) %>%
  dplyr::select(-t_) # drop time column, we don't need it for an rsf

rsf.usedpoints$case_ <- 'TRUE' # signify our used points using the amt 'case' nomenclature

# create a single dataframe
rsf.df <- rbind(rsf.randpoints, rsf.usedpoints)

#' Next we will generate the availability sample for the Step Selection and integrated Step Selection functions. 
#' Here, the availability sample is generated by drawing random steps that the animal could have taken from each recorded
#' location. We draw 15 steps per used location, and  assume a gamma step length distribution and von Mises 
#' turning angle distribution. 

## make random steps for SSF and iSSF
ssf.randsteps <- t2 %>%
  unnest(cols = steps) %>%
  random_steps(n_control = 15, 
               sl_distr = fit_distr(.$sl_, "gamma"),
               ta_distr = fit_distr(.$ta_, "vonmises"))

# explore the random steps object. How did it make the random steps? How are the signified?
head(ssf.randsteps)

# look at turning angle distribution for random steps
ssf.randsteps %>% 
  filter(case_ == FALSE) %>%
  ggplot(aes(ta_, fill = factor(id))) + geom_density(alpha = 0.4)

# look at step length distribution for random steps
ssf.randsteps %>% 
  filter(case_ == FALSE) %>%
  ggplot(aes(sl_, fill = factor(id))) + geom_density(alpha = 0.4)

# # remove the data object so we can save the csv file
# ssf.randsteps$data <- NULL
# write.csv(ssf.randsteps, './SSF/lab6_randsteps_20211112.csv')

##### 2. Resource Selection Model (Third Order Selection) #####

#' We now have used (case_ == TRUE) and available (case_ == FALSE) points for each individual. Before we can begin 
#' modeling, we have to extract covariates. We will use the amt package function to do this. 

# import layers - note that to use the amt functions they need to be raster objects, not terra objects
library(raster)
# import layers
elevation <- raster("elevation.asc")	
wells <- raster("wells_overlap.asc")		
shrub <- raster("shrub.asc")		
barren <- raster("barren.asc")		
rds <- raster("rds.asc")		

# create a stack of covs for the layers that have the same extent
stack <- stack(elevation, barren, shrub, wells, rds)

# extract covariates
rsf.df <- rsf.df %>% 
  extract_covariates(stack)

# Let's scale some covariates before we fit it
rsf.df <- rsf.df %>%
  mutate_at(.vars = c('elevation', 'rds'), .funs = scale) %>%
  mutate_at(.vars = c('barren','shrub'))

#' Our covariates are now extracted. Before model fitting, check the data frame to make sure we did everything 
#' correctly!

head(rsf.df)

### Fit RSF Model ###
#' To make things simple, we are going to forego model selection and fit the same model for each of the RSF, SSF, and 
#' iSSF so we can see how covariate estimates may differ at different orders of selection

# fit model
rsf.df$case_ <- as.factor(rsf.df$case_)
m.rsf <- rsf.df %>% fit_logit(case_ ~ elevation + barren + shrub + wells_overlap + rds)

# check out the summary
summary(m.rsf)

# viz the covariates
sjPlot::plot_model(m.rsf$model)


##### 3. Step Selection Function Model (Second Order Selection) #####
#' We now have an RSF model fit. Let's try fitting an SSF model using the same model structure. The process is a 
#' little different. We now have available locations that are related to the step, so they are time dependent. This
#' means we have to make a decision about where to extract the covariates - at the beginning or the end of the
#' step. For the SSF, let's extract at the end of the step.

library(raster)
# import layers
elevation <- raster("elevation.asc")	
wells <- raster("wells_overlap.asc")		
shrub <- raster("shrub.asc")		
barren <- raster("barren.asc")		
rds <- raster("rds.asc")		

# create a stack of covs for the layers that have the same extent
stack <- stack(elevation, barren, shrub, wells, rds)

# extract covariates -- slope and water have different extents due to different data resolutions
ssf.df <- ssf.randsteps %>% 
  extract_covariates(stack, where = 'end') 

# Lets also scale the covariates
ssf.df <- ssf.df %>%
  mutate_at(.vars = c('elevation', 'rds'), .funs = scale) %>%
  mutate_at(.vars = c('barren','shrub'), .funs = as.factor)

#write.csv(ssf.df, 'SSF/lab6_ssf_covs.csv')
#ssf.df <- read.csv('SSF/lab6_ssf_covs.csv')

#' QUESTION: Before we fit the model, notice the difference in the formula. Why do we include the `strata(step_id_)` 
#' argument in the model formula for a step selection? What is the step_id column indexing?

head(ssf.df)

# fit the ssf using fit_clogic function -- this function is just a wrapper for the clogit function in survival package
m.ssf <- ssf.df %>% fit_clogit(case_ ~ elevation + barren + shrub + wells_overlap + rds + 
                                 strata(step_id_),
                               model = TRUE)
#m.ssf <- ssf.df %>% fit_clogit(case_ ~ elevation + wells_overlap + rds + strata(step_id_), model = TRUE)

# check out the model - note that it gives us the exponentiated coefficients 
#                       and confidence intervals in the summary output
summary(m.ssf)

# viz model estimates using the sjPlot package
sjPlot::plot_model(m.ssf$model)

#' QUESTION: What changed between the RSF and SSF models? What do you think could be going on here? Which model is
#' correct?

sjPlot::plot_models(m.rsf$model, m.ssf$model,
                    m.labels = c('rsf estimates','ssf estimates'))


#' We can exponentiate habitat-selection parameters in a fitted step-selection model to compare the relative rates of 
#' use of two locations that differ by 1 unit of the explanatory variable but are otherwise equivalent - i.e., they 
#' should be equally accessible and have identical values for all other explanatory variables. We can plot this to 
#' visualize relative strength of selection (relative because it is relative to all other covariate values being held 
#' constant).
#'  
#'  To do this, we will create a dataframe of possible values for a first and second location for using elevation.
#'  Note that for all other variables, we hold them at their mean. For factors, we supply the levels of interest
#'  that were not used as the reference level in the model. 

# Make data.frame for s1
s1 <- data.frame(
  elevation = seq(from = -3, to = 3, length.out = 200),
  barren = factor("1", levels = levels(ssf.df$barren)), # set the factor level for assessment, but supply all factor levels
  shrub = factor('1', levels = levels(ssf.df$shrub)),
  rds = 0, # mean of rds, since we scale 
  wells_overlap = mean(ssf.df$wells_overlap, na.rm = TRUE))

# data.frame for s2
s2 <- data.frame(
  elevation = 0, # mean of elev, since we scaled and centered
  barren = factor("1", levels = levels(ssf.df$barren)),
  shrub = factor('1', levels = levels(ssf.df$shrub)),
  rds = 0,
  wells_overlap = mean(ssf.df$wells_overlap, na.rm = TRUE))

# Calculate log-RSS - add arguments for ci to get confidence intervals as well
lr2 <- log_rss(m.ssf, s1, s2)

# Plot using ggplot2 - note that we must exponentiate the log RSS values 
ggplot(lr2$df, aes(x = elevation_x1, y = exp(log_rss))) +
  #relative strength of selection line
  geom_line(size = 1) +
  # add an hline
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray30") +
  xlab("Elevation (SD)") +
  ylab("RSS vs Mean Elevation") +
  theme_bw()


#' QUESTION: How do you interpret this plot? What could be a nice addition to the plot?

#' Note: check out `?log_rss` to see other arguments that are available. You can supply a confidence interval
#' range to bootstrap confidence intervals for the plot, but note this can take some time. 


##### 4. Integrated Step Selection Function Model (Fourth Order Selection + Movement) #####
#' We have now fit and RSF and SSF model, which produced some differences in strength of selection for different
#' covariates. 
#' 
#' First, we need to extract the covariates again, but be intentional about where the extraction takes place. The 
#' iSSF is a movement model, so the covariates can be accounted for at the beginning of the step, the end of the
#' step, or in both locations. We are going to extract from the end of the step here. See Avgar 2019 for details on 
#' how this choice affects model interpretation. 
#' 
#' QUESTION: What would be the interpretation of the movement portion of the model if we extracted at the beginning
#' of the step?

library(raster)
# import layers
elevation <- raster("elevation.asc")	
wells <- raster("wells_overlap.asc")		
shrub <- raster("shrub.asc")		
barren <- raster("barren.asc")		
rds <- raster("rds.asc")		

# create a stack of covs for the layers that have the same extent
stack <- stack(elevation, barren, shrub, wells, rds)

# extract covariates -- slope and water have different extents due to different data resolutions
issf.df <- ssf.randsteps %>% 
  extract_covariates(stack, where = 'end') 

#' Second, we need to scale the covariate estimates and generate a few movement parameters to include in the model
issf.df <- issf.df %>%
  # first we scale
  mutate_at(.vars = c('elevation', 'rds'), .funs = scale) %>%
  mutate_at(.vars = c('barren','shrub'), .funs = as.factor) %>%
  # create covariates for the cosine of the turning angle and log step length. We will compare step length and log step length in the model
  mutate(cos_ta_ = cos(ta_),
         log_sl_ = log(sl_ + .001)) # add a small value for 

## Fit candidate models
m.issf <- issf.df %>% fit_clogit(case_ ~ elevation + barren + shrub + wells_overlap + rds +  
                               sl_ + log_sl_ + cos_ta_ + # movement parameters
                               strata(step_id_),
                               model = TRUE)

summary(m.issf)

#' Because we included movement parameters within the model, we can get updated step length and turning angle distribution 
#' estimates based on the fitted model. Along with the coefficient estimates for the movement covariates, this can tell us if 
#' selection may be impacted by movement states. 
#' 
#' First, check the tentative step length distribution shape and scale parameters. The model holds these for us:
print(m.issf$sl_) 

#' Next, update the tentative step length distribution using the model estimates - amt provides a function to do this
updated_sl <- update_sl_distr(m.issf)

print(updated_sl) # this object contains the shape and scale parameters for the updated step length distribution

#' Now we can plot the two distributions to compare them. We will need to make an empty dataframe and fill it with values
#' from the distributions

# data.frame for plotting
plot_sl <- data.frame(x = rep(NA, 1000))

# x-axis is sequence of possible step lengths
plot_sl$x <- seq(from = 0, to = 4000, length.out = 1000)

# y-axis is the probability density under the given gamma distribution
# For the tentative distribution
plot_sl$tentative <- dgamma(
  x = plot_sl$x, 
  shape = m.issf$sl_$params$shape,
  scale = m.issf$sl_$params$scale)

# For the updated distribution
plot_sl$updated <- dgamma(
  x = plot_sl$x,
  shape = updated_sl$params$shape,
  scale = updated_sl$params$scale)

# Pivot from wide data to long data
plot_sl <- plot_sl %>% 
  pivot_longer(cols = -x)

# Plot
ggplot(plot_sl, aes(x = x, y = value, color = factor(name))) +
  geom_line(size = 1) +
  xlab("Step Length (m)") +
  ylab("Probability Density") +
  scale_color_manual(name = "Distribution", 
                     breaks = c("tentative", "updated"),
                     values = c("blue", "orange")) +
  theme_bw()


#' It looks like they are pretty similar. This is expected since we did not get strong effect sizes on the movement parameters
#' in the fitted model. We can try the same for the turning angles:

# Update the distribution
updated_ta <- update_ta_distr(m.issf)

# data.frame for plotting
plot_ta <- data.frame(x = rep(NA, 100))

# x-axis is sequence of possible step lengths
plot_ta$x <- seq(from = -1 * pi, to = pi, length.out = 100)

# y-axis is the probability density under the given von Mises distribution
# For the tentative distribution
plot_ta$tentative <- circular::dvonmises(
  x = plot_ta$x, 
  mu = m.issf$ta_$params$mu,
  kappa = m.issf$ta_$params$kappa)

# For the updated distribution
plot_ta$updated <- circular::dvonmises(
  x = plot_ta$x, 
  mu = updated_ta$params$mu,
  kappa = updated_ta$params$kappa)

# Pivot from wide data to long data
plot_ta <- plot_ta %>% 
  pivot_longer(cols = -x)

# Plot
ggplot(plot_ta, aes(x = x, y = value, color = factor(name))) +
  geom_line(size = 1) +
  coord_cartesian(ylim = c(0, 0.25)) +
  xlab("Relative Turn Angle (radians)") +
  ylab("Probability Density") +
  scale_x_continuous(breaks = c(-pi, -pi/2, 0, pi/2, pi),
                     labels = c(expression(-pi, -pi/2, 0, pi/2, pi))) +
  scale_color_manual(name = "Distribution", 
                     breaks = c("tentative", "updated"),
                     values = c("blue", "orange")) +
  theme_bw()


##### 5. Interactions between movement and landscape variables #####

#' This section uses code adapted from the vignette supplied in Appendix A of Fieberg et al. 2020 
#' (https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2656.13441)
#' 
#' Lets try expanding the model to incorporate an interaction between movement and different variables. This can tell
#' us how movement changes in relation to landscape features. 
#' 
#' Lets try an interaction with barren landcover. The question we pose is 'How is movement (speed and torturosity) 
#' affected by barren landcover? Does the animal speed up or slow down when in barren landscapes? Do they travel more
#' directionally or more torturous? 
#' 
#' To do this, we first need to update the covariates to account for where the animal is at the start of the step.
#' QUESTION: Why do we want to differentiate the start and end of the step? 

# extract covariates 
issf.df2 <- ssf.randsteps %>% 
  extract_covariates(stack, where = 'both') %>%
  mutate_at(.vars = c('elevation_start','elevation_end','rds_start','rds_end'), .funs = scale) %>%
  mutate_at(.vars = c('barren_start','barren_end','shrub_start','shrub_end'), .funs = as.factor) %>%
  # create covariates for the cosine of the turning angle and log step length. We will compare step length and log step length in the model
  mutate(cos_ta_ = cos(ta_),
         log_sl_ = log(sl_ + .001)) # add a small value for 


# how did the cov names change?
head(issf.df2)

#' Fit candidate models# fit the model and supply interaction terms
#' Under this model, Lupe’s selection-free movement kernel depends on the value of barren at the start of the movement 
#' step and Lupe’s step-selection function depends on the value of barren at the end of the movement step.

m.barren <- issf.df2 %>% fit_clogit(case_ ~ elevation_end + barren_end + shrub_end + wells_overlap_end + rds_end +
                                    sl_ + log_sl_ + cos_ta_ + 
                                    barren_start:(sl_ + log_sl_ + cos_ta_) + # interaction of barren and move params      
                                    strata(step_id_))

# check the model
summary(m.barren)

#' We will now plot the predicted step length and turning angle distributions for movement in relation to barren 
#' landcover. We will start with step length distributions, which we derive using the estimates from the model.
#' Note that with factors, the reference level can be found using the estimates for step length and log step length. 
#' The code below uses the model estimates to derive shape and scale parameters of the step length distribution in 
#' relation to the 

# non-barren step-length distribution = treated as reference level
nobarren_sl <- update_gamma(
  dist = m.barren$sl_,
  beta_sl = m.barren$model$coefficients["sl_"], 
  beta_log_sl = m.barren$model$coefficients["log_sl_"]) 

# Barren step-length distribution
barren_sl <- update_gamma(
  dist = m.barren$sl_,
  beta_sl = m.barren$model$coefficients["sl_"] +
    m.barren$model$coefficients["sl_:barren_start1"],
  beta_log_sl = m.barren$model$coefficients["log_sl_"] +
    m.barren$model$coefficients["log_sl_:barren_start1"])

## Plot for step length distribution

#data.frame for plotting
plot_sl <- data.frame(x = rep(NA, 1000))

# x-axis is sequence of possible step lengths
plot_sl$x <- seq(from = 0, to = 4000, length.out = 1000)

# Not Barren
plot_sl$nobarren <- dgamma(x = plot_sl$x, 
                      shape = nobarren_sl$params$shape,
                      scale = nobarren_sl$params$scale)
# Barren
plot_sl$barren <- dgamma(x = plot_sl$x, 
                       shape = barren_sl$params$shape,
                       scale = barren_sl$params$scale)

# Pivot from wide to long data
plot_sl <- plot_sl %>% 
  pivot_longer(cols = -x)

# Plot 
p1 <- ggplot(plot_sl, aes(x = x, y = value, color = factor(name))) +
  geom_line(size = 1) +
  scale_color_manual(name = "barren",
                     breaks = c("nobarren", "barren"),
                     values = c("navyblue", "firebrick")) +
  xlab("Step Length (m)") +
  ylab("Probability Density") +
  theme_bw() 

## Plot the turning angle distributions

# no-shrub turn-angle distribution
nobarren_ta <- update_vonmises(
  dist = m.barren$ta_, beta_cos_ta = m.barren$model$coefficients["cos_ta_"])

# Shrub turn-angle distribution
barren_ta <- update_vonmises(
  dist = m.barren$ta_, 
  beta_cos_ta = m.barren$model$coefficients["cos_ta_"] +
    m.barren$model$coefficients["cos_ta_:barren_start1"])

#data.frame for plotting
plot_ta <- data.frame(x = rep(NA, 100))

# x-axis is sequence of possible step lengths
plot_ta$x <- seq(from = -pi, to = pi, length.out = 100)

# y-axis is the probability density under the given gamma distribution
# no shrub
plot_ta$nobarren <- circular::dvonmises(x = plot_ta$x, 
                                      kappa = nobarren_ta$params$kappa,
                                      mu = 0)
# shrub
plot_ta$barren <- circular::dvonmises(x = plot_ta$x, 
                                     kappa = barren_ta$params$kappa,
                                     mu = 0)

# Pivot from wide to long data
plot_ta <- plot_ta %>% 
  pivot_longer(cols = -x)

p2 <- ggplot(plot_ta, aes(x = x, y = value, color = factor(name))) +
  geom_line(size = 1) +
  scale_color_manual(name = "barren",
                     breaks = c("nobarren", "barren"),
                     values = c("navyblue", "firebrick")) +
  scale_x_continuous(breaks = c(-pi, -pi/2, 0, pi/2, pi),
                     labels = c(expression(-pi, -pi/2, 0, pi/2, pi))) +
  xlab("Turn Angle (radians)") +
  ylab("Probability Density") +
  theme_bw()


#' Now we can look at the plots!
#' 
#' #' QUESTION: What does the y axis of the plots represent? What do the plots tell you about how movement patterns change
#' when the deer is in barren and non-barren land?

# step length
p1

# turn angle
p2

##### END OF LAB #####
